{
  "issue_id": "_openai_codex_issue_006",
  "title": "usableAsTool object dropped for HTTP Request",
  "severity": "medium",
  "status": "new",
  "priority": 2,
  "metadata": {
    "created_at": "2025-11-06T17:14:00Z",
    "created_by": "openai_codex",
    "affected_nodes": "HTTP Request (V3) – likely any node that assigns an object to usableAsTool"
  },
  "description": {
    "problem": "The extractor writes `node_info.usableAsTool` as null when the source description assigns a structured object instead of a boolean.",
    "impact": "Medium – HTTP Request is one of the flagship tool-enabled nodes. Losing the replacement configuration prevents tooling from exposing recommended subcategories (e.g., Codex tooling hints).",
    "root_cause": "The metadata serializer treats `usableAsTool` as a boolean flag and ignores object literals. In `HttpRequestV3.node.ts` the property is an object with nested replacements, which the current code path drops entirely.",
    "evidence": [
      "extracted_docs/httpRequest_data.json: node_info.usableAsTool → null",
      "n8n/packages/nodes-base/nodes/HttpRequest/V3/HttpRequestV3.node.ts:72-101 defines `usableAsTool` with nested replacements",
      "extracted_docs/slack_data.json: node_info.usableAsTool → true (boolean case proves the field is only handled for primitive values)"
    ],
    "fix_approach": "1. Allow `usableAsTool` to remain a dict when encountered during metadata extraction. 2. Ensure the JSON serializer handles nested dicts safely. 3. Re-extract HTTP Request and verify the replacements object appears in `node_info`. 4. Run `python3 validate_extraction.py` and inspect other tool-enabled nodes."
  },
  "ownership": {
    "assigned_to": null,
    "locked_by": null,
    "lock_acquired_at": null,
    "lock_expires_at": null,
    "claimed_at": null
  }
}
